{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { useChatContext } from '../context/ChatContext';\nconst useWebSocket = () => {\n  _s();\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [reconnectAttempts, setReconnectAttempts] = useState(0);\n  const MAX_RECONNECT_ATTEMPTS = 5;\n  const RECONNECT_DELAY = 8000;\n  const {\n    username,\n    isLoggedIn,\n    addMessage,\n    setMessageHistory,\n    setOnlineUsers\n  } = useChatContext();\n  const connect = useCallback(() => {\n    if (!isLoggedIn || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) return;\n\n    // Clean up existing connection\n    if (wsRef.current) {\n      wsRef.current.close();\n    }\n    const websocket = new WebSocket('ws://localhost:8000');\n    websocket.onopen = () => {\n      console.log('Connected to server');\n      setIsConnected(true);\n      setReconnectAttempts(0);\n      websocket.send(JSON.stringify({\n        type: 'join',\n        username\n      }));\n    };\n    websocket.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        if (data.type === 'history') {\n          setMessageHistory(data.messages);\n        } else if (data.type === 'message') {\n          addMessage(data.message);\n        } else if (data.type === 'users') {\n          setOnlineUsers(data.count);\n        }\n      } catch (error) {\n        console.error('Error parsing message:', error);\n      }\n    };\n    websocket.onerror = error => {\n      console.error('WebSocket error:', error);\n    };\n    websocket.onclose = () => {\n      console.log('Disconnected from server');\n      setIsConnected(false);\n      wsRef.current = null;\n\n      // Attempt reconnection with delay\n      if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n        reconnectTimeoutRef.current = setTimeout(() => {\n          console.log(`Reconnection attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS}`);\n          setReconnectAttempts(prev => prev + 1);\n        }, RECONNECT_DELAY);\n      } else {\n        console.error('Max reconnection attempts reached');\n      }\n    };\n    wsRef.current = websocket;\n  }, [isLoggedIn, username, reconnectAttempts, addMessage, setMessageHistory, setOnlineUsers]);\n\n  // Handle reconnection attempts\n  useEffect(() => {\n    if (reconnectAttempts > 0 && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n      connect();\n    }\n  }, [reconnectAttempts, connect]);\n\n  // Initial connection\n  useEffect(() => {\n    if (isLoggedIn && username) {\n      setReconnectAttempts(0);\n      connect();\n    }\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (wsRef.current) {\n        wsRef.current.close();\n        wsRef.current = null;\n      }\n    };\n  }, [isLoggedIn, username]); // Only reconnect when login status or username changes\n\n  const sendMessage = useCallback(text => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'message',\n        text,\n        username\n      }));\n      return true;\n    }\n    console.warn('WebSocket is not connected');\n    return false;\n  }, [username]);\n  return {\n    sendMessage,\n    isConnected,\n    reconnectAttempts\n  };\n};\n_s(useWebSocket, \"YueKBSMbYOCNYSPUwKc6cWIXF0o=\", false, function () {\n  return [useChatContext];\n});\nexport default useWebSocket;","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","useChatContext","useWebSocket","_s","wsRef","reconnectTimeoutRef","isConnected","setIsConnected","reconnectAttempts","setReconnectAttempts","MAX_RECONNECT_ATTEMPTS","RECONNECT_DELAY","username","isLoggedIn","addMessage","setMessageHistory","setOnlineUsers","connect","current","close","websocket","WebSocket","onopen","console","log","send","JSON","stringify","type","onmessage","event","data","parse","messages","message","count","error","onerror","onclose","setTimeout","prev","clearTimeout","sendMessage","text","readyState","OPEN","warn"],"sources":["C:/Users/skk46/OneDrive/AppData/Desktop/chat-app-full/chat-app/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\r\nimport { useChatContext } from '../context/ChatContext';\r\n\r\nconst useWebSocket = () => {\r\n  const wsRef = useRef(null);\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [reconnectAttempts, setReconnectAttempts] = useState(0);\r\n  const MAX_RECONNECT_ATTEMPTS = 5;\r\n  const RECONNECT_DELAY = 8000;\r\n  \r\n  const { \r\n    username, \r\n    isLoggedIn, \r\n    addMessage, \r\n    setMessageHistory, \r\n    setOnlineUsers \r\n  } = useChatContext();\r\n\r\n  const connect = useCallback(() => {\r\n    if (!isLoggedIn || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) return;\r\n\r\n    // Clean up existing connection\r\n    if (wsRef.current) {\r\n      wsRef.current.close();\r\n    }\r\n\r\n    const websocket = new WebSocket('ws://localhost:8000');\r\n\r\n    websocket.onopen = () => {\r\n      console.log('Connected to server');\r\n      setIsConnected(true);\r\n      setReconnectAttempts(0);\r\n      websocket.send(JSON.stringify({ type: 'join', username }));\r\n    };\r\n\r\n    websocket.onmessage = (event) => {\r\n      try {\r\n        const data = JSON.parse(event.data);\r\n\r\n        if (data.type === 'history') {\r\n          setMessageHistory(data.messages);\r\n        } else if (data.type === 'message') {\r\n          addMessage(data.message);\r\n        } else if (data.type === 'users') {\r\n          setOnlineUsers(data.count);\r\n        }\r\n      } catch (error) {\r\n        console.error('Error parsing message:', error);\r\n      }\r\n    };\r\n\r\n    websocket.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n    };\r\n\r\n    websocket.onclose = () => {\r\n      console.log('Disconnected from server');\r\n      setIsConnected(false);\r\n      wsRef.current = null;\r\n      \r\n      // Attempt reconnection with delay\r\n      if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\r\n        reconnectTimeoutRef.current = setTimeout(() => {\r\n          console.log(`Reconnection attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS}`);\r\n          setReconnectAttempts(prev => prev + 1);\r\n        }, RECONNECT_DELAY);\r\n      } else {\r\n        console.error('Max reconnection attempts reached');\r\n      }\r\n    };\r\n\r\n    wsRef.current = websocket;\r\n  }, [isLoggedIn, username, reconnectAttempts, addMessage, setMessageHistory, setOnlineUsers]);\r\n\r\n  // Handle reconnection attempts\r\n  useEffect(() => {\r\n    if (reconnectAttempts > 0 && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\r\n      connect();\r\n    }\r\n  }, [reconnectAttempts, connect]);\r\n\r\n  // Initial connection\r\n  useEffect(() => {\r\n    if (isLoggedIn && username) {\r\n      setReconnectAttempts(0);\r\n      connect();\r\n    }\r\n\r\n    return () => {\r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n      }\r\n      if (wsRef.current) {\r\n        wsRef.current.close();\r\n        wsRef.current = null;\r\n      }\r\n    };\r\n  }, [isLoggedIn, username]); // Only reconnect when login status or username changes\r\n\r\n  const sendMessage = useCallback((text) => {\r\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\r\n      wsRef.current.send(\r\n        JSON.stringify({\r\n          type: 'message',\r\n          text,\r\n          username\r\n        })\r\n      );\r\n      return true;\r\n    }\r\n    console.warn('WebSocket is not connected');\r\n    return false;\r\n  }, [username]);\r\n\r\n  return { sendMessage, isConnected, reconnectAttempts };\r\n};\r\n\r\nexport default useWebSocket;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}