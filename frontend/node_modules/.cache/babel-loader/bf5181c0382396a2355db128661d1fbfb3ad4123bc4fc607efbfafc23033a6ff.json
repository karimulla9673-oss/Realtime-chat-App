{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from 'react';\nimport { useChatContext } from '../context/ChatContext';\nconst useWebSocket = () => {\n  _s();\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [reconnectAttempts, setReconnectAttempts] = useState(0);\n  const MAX_RECONNECT_ATTEMPTS = 5;\n  const RECONNECT_DELAY = 3000; // 3 seconds\n\n  const {\n    username,\n    isLoggedIn,\n    addMessage,\n    setMessageHistory,\n    setOnlineUsers\n  } = useChatContext();\n  const connect = () => {\n    if (!isLoggedIn || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) return;\n\n    // Clean up existing connection\n    if (wsRef.current) {\n      wsRef.current.close();\n    }\n    const websocket = new WebSocket('ws://localhost:8000');\n    websocket.onopen = () => {\n      console.log('Connected to server');\n      setIsConnected(true);\n      setReconnectAttempts(0);\n      websocket.send(JSON.stringify({\n        type: 'join',\n        username\n      }));\n    };\n    websocket.onmessage = event => {\n      const data = JSON.parse(event.data);\n      if (data.type === 'history') {\n        setMessageHistory(data.messages);\n      } else if (data.type === 'message') {\n        addMessage(data.message);\n      } else if (data.type === 'users') {\n        setOnlineUsers(data.count);\n      }\n    };\n    websocket.onerror = error => {\n      console.error('WebSocket error:', error);\n    };\n    websocket.onclose = () => {\n      console.log('Disconnected from server');\n      setIsConnected(false);\n\n      // Attempt reconnection with delay\n      if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n        reconnectTimeoutRef.current = setTimeout(() => {\n          console.log(`Reconnection attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS}`);\n          setReconnectAttempts(prev => prev + 1);\n          connect();\n        }, RECONNECT_DELAY);\n      } else {\n        console.error('Max reconnection attempts reached');\n      }\n    };\n    wsRef.current = websocket;\n  };\n  useEffect(() => {\n    if (isLoggedIn) {\n      connect();\n    }\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n        wsRef.current.close();\n      }\n    };\n  }, [isLoggedIn]); // Only reconnect when login status changes\n\n  const sendMessage = text => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'message',\n        text,\n        username\n      }));\n      return true;\n    }\n    return false;\n  };\n  return {\n    sendMessage,\n    isConnected,\n    reconnectAttempts\n  };\n};\n_s(useWebSocket, \"Urc3clgi0M/h3mf3WqQl+ILQuRg=\", false, function () {\n  return [useChatContext];\n});\nexport default useWebSocket;","map":{"version":3,"names":["useEffect","useRef","useState","useChatContext","useWebSocket","_s","wsRef","reconnectTimeoutRef","isConnected","setIsConnected","reconnectAttempts","setReconnectAttempts","MAX_RECONNECT_ATTEMPTS","RECONNECT_DELAY","username","isLoggedIn","addMessage","setMessageHistory","setOnlineUsers","connect","current","close","websocket","WebSocket","onopen","console","log","send","JSON","stringify","type","onmessage","event","data","parse","messages","message","count","onerror","error","onclose","setTimeout","prev","clearTimeout","readyState","OPEN","sendMessage","text"],"sources":["C:/Users/skk46/OneDrive/AppData/Desktop/chat-app-full/chat-app/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\r\nimport { useChatContext } from '../context/ChatContext';\r\n\r\nconst useWebSocket = () => {\r\n  const wsRef = useRef(null);\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [reconnectAttempts, setReconnectAttempts] = useState(0);\r\n  const MAX_RECONNECT_ATTEMPTS = 5;\r\n  const RECONNECT_DELAY = 3000; // 3 seconds\r\n  \r\n  const { \r\n    username, \r\n    isLoggedIn, \r\n    addMessage, \r\n    setMessageHistory, \r\n    setOnlineUsers \r\n  } = useChatContext();\r\n\r\n  const connect = () => {\r\n    if (!isLoggedIn || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) return;\r\n\r\n    // Clean up existing connection\r\n    if (wsRef.current) {\r\n      wsRef.current.close();\r\n    }\r\n\r\n    const websocket = new WebSocket('ws://localhost:8000');\r\n\r\n    websocket.onopen = () => {\r\n      console.log('Connected to server');\r\n      setIsConnected(true);\r\n      setReconnectAttempts(0);\r\n      websocket.send(JSON.stringify({ type: 'join', username }));\r\n    };\r\n\r\n    websocket.onmessage = (event) => {\r\n      const data = JSON.parse(event.data);\r\n\r\n      if (data.type === 'history') {\r\n        setMessageHistory(data.messages);\r\n      } else if (data.type === 'message') {\r\n        addMessage(data.message);\r\n      } else if (data.type === 'users') {\r\n        setOnlineUsers(data.count);\r\n      }\r\n    };\r\n\r\n    websocket.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n    };\r\n\r\n    websocket.onclose = () => {\r\n      console.log('Disconnected from server');\r\n      setIsConnected(false);\r\n      \r\n      // Attempt reconnection with delay\r\n      if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\r\n        reconnectTimeoutRef.current = setTimeout(() => {\r\n          console.log(`Reconnection attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS}`);\r\n          setReconnectAttempts(prev => prev + 1);\r\n          connect();\r\n        }, RECONNECT_DELAY);\r\n      } else {\r\n        console.error('Max reconnection attempts reached');\r\n      }\r\n    };\r\n\r\n    wsRef.current = websocket;\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (isLoggedIn) {\r\n      connect();\r\n    }\r\n\r\n    return () => {\r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n      }\r\n      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\r\n        wsRef.current.close();\r\n      }\r\n    };\r\n  }, [isLoggedIn]); // Only reconnect when login status changes\r\n\r\n  const sendMessage = (text) => {\r\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\r\n      wsRef.current.send(\r\n        JSON.stringify({\r\n          type: 'message',\r\n          text,\r\n          username\r\n        })\r\n      );\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  return { sendMessage, isConnected, reconnectAttempts };\r\n};\r\n\r\nexport default useWebSocket;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}