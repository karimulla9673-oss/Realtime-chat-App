{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from 'react';\nconst useWebSocket = url => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [messages, setMessages] = useState([]);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n  const maxReconnectAttempts = 5;\n  const reconnectDelay = 3000; // 3 seconds\n\n  const connect = () => {\n    var _wsRef$current, _wsRef$current2;\n    // Clear any existing connection\n    if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN || ((_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.readyState) === WebSocket.CONNECTING) {\n      console.log('WebSocket already connecting/connected');\n      return;\n    }\n    try {\n      console.log('Attempting to connect to WebSocket...');\n      const ws = new WebSocket(url);\n      ws.onopen = () => {\n        console.log('Connected to server');\n        setIsConnected(true);\n        reconnectAttemptsRef.current = 0; // Reset reconnection attempts\n      };\n      ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          setMessages(prev => [...prev, data]);\n        } catch (error) {\n          console.error('Error parsing message:', error);\n        }\n      };\n      ws.onerror = error => {\n        console.error('WebSocket error:', error);\n      };\n      ws.onclose = () => {\n        console.log('Disconnected from server');\n        setIsConnected(false);\n        wsRef.current = null;\n\n        // Attempt to reconnect\n        if (reconnectAttemptsRef.current < maxReconnectAttempts) {\n          reconnectAttemptsRef.current += 1;\n          console.log(`Reconnection attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts}`);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, reconnectDelay);\n        } else {\n          console.error('Max reconnection attempts reached');\n        }\n      };\n      wsRef.current = ws;\n    } catch (error) {\n      console.error('WebSocket connection failed:', error);\n    }\n  };\n  useEffect(() => {\n    // Initial connection with a small delay to ensure server is ready\n    const initialTimeout = setTimeout(connect, 500);\n    return () => {\n      clearTimeout(initialTimeout);\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n    };\n  }, [url]);\n  const sendMessage = message => {\n    var _wsRef$current3;\n    if (((_wsRef$current3 = wsRef.current) === null || _wsRef$current3 === void 0 ? void 0 : _wsRef$current3.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n      return true;\n    } else {\n      console.error('WebSocket is not connected');\n      return false;\n    }\n  };\n  return {\n    isConnected,\n    messages,\n    sendMessage\n  };\n};\n_s(useWebSocket, \"SzcV5iQ9Y3hdRdMR+i3tYtJ3tqA=\");\nexport default useWebSocket;","map":{"version":3,"names":["useEffect","useRef","useState","useWebSocket","url","_s","isConnected","setIsConnected","messages","setMessages","wsRef","reconnectTimeoutRef","reconnectAttemptsRef","maxReconnectAttempts","reconnectDelay","connect","_wsRef$current","_wsRef$current2","current","readyState","WebSocket","OPEN","CONNECTING","console","log","ws","onopen","onmessage","event","data","JSON","parse","prev","error","onerror","onclose","setTimeout","initialTimeout","clearTimeout","close","sendMessage","message","_wsRef$current3","send","stringify"],"sources":["C:/Users/skk46/OneDrive/AppData/Desktop/chat-app-full/chat-app/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\r\n\r\nconst useWebSocket = (url) => {\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [messages, setMessages] = useState([]);\r\n  const wsRef = useRef(null);\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const reconnectAttemptsRef = useRef(0);\r\n  const maxReconnectAttempts = 5;\r\n  const reconnectDelay = 3000; // 3 seconds\r\n\r\n  const connect = () => {\r\n    // Clear any existing connection\r\n    if (wsRef.current?.readyState === WebSocket.OPEN || \r\n        wsRef.current?.readyState === WebSocket.CONNECTING) {\r\n      console.log('WebSocket already connecting/connected');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      console.log('Attempting to connect to WebSocket...');\r\n      const ws = new WebSocket(url);\r\n      \r\n      ws.onopen = () => {\r\n        console.log('Connected to server');\r\n        setIsConnected(true);\r\n        reconnectAttemptsRef.current = 0; // Reset reconnection attempts\r\n      };\r\n\r\n      ws.onmessage = (event) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          setMessages((prev) => [...prev, data]);\r\n        } catch (error) {\r\n          console.error('Error parsing message:', error);\r\n        }\r\n      };\r\n\r\n      ws.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n      };\r\n\r\n      ws.onclose = () => {\r\n        console.log('Disconnected from server');\r\n        setIsConnected(false);\r\n        wsRef.current = null;\r\n\r\n        // Attempt to reconnect\r\n        if (reconnectAttemptsRef.current < maxReconnectAttempts) {\r\n          reconnectAttemptsRef.current += 1;\r\n          console.log(`Reconnection attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts}`);\r\n          \r\n          reconnectTimeoutRef.current = setTimeout(() => {\r\n            connect();\r\n          }, reconnectDelay);\r\n        } else {\r\n          console.error('Max reconnection attempts reached');\r\n        }\r\n      };\r\n\r\n      wsRef.current = ws;\r\n    } catch (error) {\r\n      console.error('WebSocket connection failed:', error);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    // Initial connection with a small delay to ensure server is ready\r\n    const initialTimeout = setTimeout(connect, 500);\r\n\r\n    return () => {\r\n      clearTimeout(initialTimeout);\r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n      }\r\n      if (wsRef.current) {\r\n        wsRef.current.close();\r\n      }\r\n    };\r\n  }, [url]);\r\n\r\n  const sendMessage = (message) => {\r\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\r\n      wsRef.current.send(JSON.stringify(message));\r\n      return true;\r\n    } else {\r\n      console.error('WebSocket is not connected');\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return { isConnected, messages, sendMessage };\r\n};\r\n\r\nexport default useWebSocket;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}