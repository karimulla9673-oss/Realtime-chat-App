{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from 'react';\nimport { useChatContext } from '../context/ChatContext';\nconst useWebSocket = () => {\n  _s();\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n  const [isConnected, setIsConnected] = useState(false);\n  const MAX_RECONNECT_ATTEMPTS = 5;\n  const RECONNECT_DELAY = 3000;\n  const {\n    username,\n    isLoggedIn,\n    addMessage,\n    setMessageHistory,\n    setOnlineUsers\n  } = useChatContext();\n\n  // ‚úÖ Get WebSocket URL with proper fallback\n  const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000';\n  useEffect(() => {\n    if (!isLoggedIn || !username) return;\n\n    // Reset reconnect attempts when starting fresh\n    reconnectAttemptsRef.current = 0;\n    const connect = () => {\n      // Stop if max attempts reached\n      if (reconnectAttemptsRef.current >= MAX_RECONNECT_ATTEMPTS) {\n        console.error('üö´ Max reconnection attempts reached');\n        return;\n      }\n\n      // Close any existing connection\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n      console.log(`üîå Connecting to ${WS_URL}...`);\n      const websocket = new WebSocket(WS_URL);\n      websocket.onopen = () => {\n        console.log('‚úÖ Connected to server');\n        setIsConnected(true);\n        reconnectAttemptsRef.current = 0;\n        websocket.send(JSON.stringify({\n          type: 'join',\n          username\n        }));\n      };\n      websocket.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          if (data.type === 'history') {\n            setMessageHistory(data.messages);\n          } else if (data.type === 'message') {\n            addMessage(data.message);\n          } else if (data.type === 'users') {\n            setOnlineUsers(data.count);\n          }\n        } catch (error) {\n          console.error('‚ö†Ô∏è Error parsing message:', error);\n        }\n      };\n      websocket.onerror = error => {\n        console.error('‚ö†Ô∏è WebSocket error:', error);\n      };\n      websocket.onclose = event => {\n        console.log('‚ùå Disconnected from server', event.code, event.reason);\n        setIsConnected(false);\n\n        // Only attempt reconnection if not a clean close and haven't exceeded max attempts\n        if (event.code !== 1000 && reconnectAttemptsRef.current < MAX_RECONNECT_ATTEMPTS) {\n          reconnectAttemptsRef.current += 1;\n          console.log(`üîÑ Reconnection attempt ${reconnectAttemptsRef.current}/${MAX_RECONNECT_ATTEMPTS} in ${RECONNECT_DELAY}ms`);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, RECONNECT_DELAY);\n        }\n      };\n      wsRef.current = websocket;\n    };\n\n    // Initial connection\n    connect();\n\n    // Cleanup function\n    return () => {\n      console.log('üßπ Cleaning up WebSocket connection');\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (wsRef.current) {\n        // Set to max attempts to prevent reconnection during cleanup\n        reconnectAttemptsRef.current = MAX_RECONNECT_ATTEMPTS;\n        wsRef.current.close(1000, 'Component unmounting');\n        wsRef.current = null;\n      }\n    };\n  }, [isLoggedIn, username, WS_URL, addMessage, setMessageHistory, setOnlineUsers]);\n\n  // ‚úÖ Send message helper\n  const sendMessage = text => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'message',\n        text,\n        username\n      }));\n      return true;\n    }\n    console.warn('‚ö†Ô∏è WebSocket is not connected');\n    return false;\n  };\n  return {\n    sendMessage,\n    isConnected,\n    reconnectAttempts: reconnectAttemptsRef.current\n  };\n};\n_s(useWebSocket, \"2lm92C8QPzt1XRSWYCR5mWae6Ks=\", false, function () {\n  return [useChatContext];\n});\nexport default useWebSocket;","map":{"version":3,"names":["useEffect","useRef","useState","useChatContext","useWebSocket","_s","wsRef","reconnectTimeoutRef","reconnectAttemptsRef","isConnected","setIsConnected","MAX_RECONNECT_ATTEMPTS","RECONNECT_DELAY","username","isLoggedIn","addMessage","setMessageHistory","setOnlineUsers","WS_URL","process","env","REACT_APP_WS_URL","current","connect","console","error","close","log","websocket","WebSocket","onopen","send","JSON","stringify","type","onmessage","event","data","parse","messages","message","count","onerror","onclose","code","reason","setTimeout","clearTimeout","sendMessage","text","readyState","OPEN","warn","reconnectAttempts"],"sources":["C:/Users/skk46/OneDrive/AppData/Desktop/chat-app-full/chat-app/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\r\nimport { useChatContext } from '../context/ChatContext';\r\n\r\nconst useWebSocket = () => {\r\n  const wsRef = useRef(null);\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const reconnectAttemptsRef = useRef(0);\r\n\r\n  const [isConnected, setIsConnected] = useState(false);\r\n\r\n  const MAX_RECONNECT_ATTEMPTS = 5;\r\n  const RECONNECT_DELAY = 3000;\r\n\r\n  const {\r\n    username,\r\n    isLoggedIn,\r\n    addMessage,\r\n    setMessageHistory,\r\n    setOnlineUsers,\r\n  } = useChatContext();\r\n\r\n  // ‚úÖ Get WebSocket URL with proper fallback\r\n  const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000';\r\n\r\n  useEffect(() => {\r\n    if (!isLoggedIn || !username) return;\r\n\r\n    // Reset reconnect attempts when starting fresh\r\n    reconnectAttemptsRef.current = 0;\r\n\r\n    const connect = () => {\r\n      // Stop if max attempts reached\r\n      if (reconnectAttemptsRef.current >= MAX_RECONNECT_ATTEMPTS) {\r\n        console.error('üö´ Max reconnection attempts reached');\r\n        return;\r\n      }\r\n\r\n      // Close any existing connection\r\n      if (wsRef.current) {\r\n        wsRef.current.close();\r\n      }\r\n\r\n      console.log(`üîå Connecting to ${WS_URL}...`);\r\n      const websocket = new WebSocket(WS_URL);\r\n\r\n      websocket.onopen = () => {\r\n        console.log('‚úÖ Connected to server');\r\n        setIsConnected(true);\r\n        reconnectAttemptsRef.current = 0;\r\n        websocket.send(JSON.stringify({ type: 'join', username }));\r\n      };\r\n\r\n      websocket.onmessage = (event) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n\r\n          if (data.type === 'history') {\r\n            setMessageHistory(data.messages);\r\n          } else if (data.type === 'message') {\r\n            addMessage(data.message);\r\n          } else if (data.type === 'users') {\r\n            setOnlineUsers(data.count);\r\n          }\r\n        } catch (error) {\r\n          console.error('‚ö†Ô∏è Error parsing message:', error);\r\n        }\r\n      };\r\n\r\n      websocket.onerror = (error) => {\r\n        console.error('‚ö†Ô∏è WebSocket error:', error);\r\n      };\r\n\r\n      websocket.onclose = (event) => {\r\n        console.log('‚ùå Disconnected from server', event.code, event.reason);\r\n        setIsConnected(false);\r\n\r\n        // Only attempt reconnection if not a clean close and haven't exceeded max attempts\r\n        if (event.code !== 1000 && reconnectAttemptsRef.current < MAX_RECONNECT_ATTEMPTS) {\r\n          reconnectAttemptsRef.current += 1;\r\n          console.log(\r\n            `üîÑ Reconnection attempt ${reconnectAttemptsRef.current}/${MAX_RECONNECT_ATTEMPTS} in ${RECONNECT_DELAY}ms`\r\n          );\r\n          \r\n          reconnectTimeoutRef.current = setTimeout(() => {\r\n            connect();\r\n          }, RECONNECT_DELAY);\r\n        }\r\n      };\r\n\r\n      wsRef.current = websocket;\r\n    };\r\n\r\n    // Initial connection\r\n    connect();\r\n\r\n    // Cleanup function\r\n    return () => {\r\n      console.log('üßπ Cleaning up WebSocket connection');\r\n      \r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n      }\r\n      \r\n      if (wsRef.current) {\r\n        // Set to max attempts to prevent reconnection during cleanup\r\n        reconnectAttemptsRef.current = MAX_RECONNECT_ATTEMPTS;\r\n        wsRef.current.close(1000, 'Component unmounting');\r\n        wsRef.current = null;\r\n      }\r\n    };\r\n  }, [isLoggedIn, username, WS_URL, addMessage, setMessageHistory, setOnlineUsers]);\r\n\r\n  // ‚úÖ Send message helper\r\n  const sendMessage = (text) => {\r\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\r\n      wsRef.current.send(\r\n        JSON.stringify({\r\n          type: 'message',\r\n          text,\r\n          username,\r\n        })\r\n      );\r\n      return true;\r\n    }\r\n    console.warn('‚ö†Ô∏è WebSocket is not connected');\r\n    return false;\r\n  };\r\n\r\n  return { \r\n    sendMessage, \r\n    isConnected, \r\n    reconnectAttempts: reconnectAttemptsRef.current \r\n  };\r\n};\r\n\r\nexport default useWebSocket;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}