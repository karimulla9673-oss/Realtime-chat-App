{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { useChatContext } from '../context/ChatContext';\nconst useWebSocket = () => {\n  _s();\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n  const isConnectingRef = useRef(false);\n  const [isConnected, setIsConnected] = useState(false);\n  const MAX_RECONNECT_ATTEMPTS = 5;\n  const RECONNECT_DELAY = 3000;\n  const {\n    username,\n    isLoggedIn,\n    addMessage,\n    setMessageHistory,\n    setOnlineUsers\n  } = useChatContext();\n\n  // ‚úÖ Get WebSocket URL with proper fallback\n  const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000';\n\n  // ‚úÖ Memoize the message handler to prevent recreating it\n  const handleMessage = useCallback(event => {\n    try {\n      const data = JSON.parse(event.data);\n      if (data.type === 'history') {\n        setMessageHistory(data.messages);\n      } else if (data.type === 'message') {\n        addMessage(data.message);\n      } else if (data.type === 'users') {\n        setOnlineUsers(data.count);\n      }\n    } catch (error) {\n      console.error('‚ö†Ô∏è Error parsing message:', error);\n    }\n  }, [addMessage, setMessageHistory, setOnlineUsers]);\n  useEffect(() => {\n    if (!isLoggedIn || !username) {\n      return;\n    }\n\n    // Prevent multiple simultaneous connection attempts\n    if (isConnectingRef.current) {\n      return;\n    }\n\n    // Reset reconnect attempts when starting fresh\n    reconnectAttemptsRef.current = 0;\n    const connect = () => {\n      // Stop if max attempts reached\n      if (reconnectAttemptsRef.current >= MAX_RECONNECT_ATTEMPTS) {\n        console.error('üö´ Max reconnection attempts reached');\n        isConnectingRef.current = false;\n        return;\n      }\n\n      // Prevent multiple connections\n      if (isConnectingRef.current) {\n        return;\n      }\n      isConnectingRef.current = true;\n\n      // Close any existing connection\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n      console.log(`üîå Connecting to ${WS_URL}...`);\n      const websocket = new WebSocket(WS_URL);\n      websocket.onopen = () => {\n        console.log('‚úÖ Connected to server');\n        setIsConnected(true);\n        reconnectAttemptsRef.current = 0;\n        isConnectingRef.current = false;\n        websocket.send(JSON.stringify({\n          type: 'join',\n          username\n        }));\n      };\n      websocket.onmessage = handleMessage;\n      websocket.onerror = error => {\n        console.error('‚ö†Ô∏è WebSocket error:', error);\n        isConnectingRef.current = false;\n      };\n      websocket.onclose = event => {\n        console.log('‚ùå Disconnected from server', event.code, event.reason);\n        setIsConnected(false);\n        isConnectingRef.current = false;\n\n        // Only attempt reconnection if not a clean close and haven't exceeded max attempts\n        if (event.code !== 1000 && reconnectAttemptsRef.current < MAX_RECONNECT_ATTEMPTS) {\n          reconnectAttemptsRef.current += 1;\n          console.log(`üîÑ Reconnection attempt ${reconnectAttemptsRef.current}/${MAX_RECONNECT_ATTEMPTS} in ${RECONNECT_DELAY}ms`);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, RECONNECT_DELAY);\n        }\n      };\n      wsRef.current = websocket;\n    };\n\n    // Initial connection\n    connect();\n\n    // Cleanup function\n    return () => {\n      console.log('üßπ Cleaning up WebSocket connection');\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n        reconnectTimeoutRef.current = null;\n      }\n      if (wsRef.current) {\n        // Set to max attempts to prevent reconnection during cleanup\n        reconnectAttemptsRef.current = MAX_RECONNECT_ATTEMPTS;\n        wsRef.current.onclose = null; // Remove onclose handler to prevent reconnection\n        wsRef.current.close(1000, 'Component unmounting');\n        wsRef.current = null;\n      }\n      isConnectingRef.current = false;\n    };\n  }, [isLoggedIn, username, WS_URL, handleMessage]);\n\n  // ‚úÖ Send message helper - memoized to prevent recreating\n  const sendMessage = useCallback(text => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'message',\n        text,\n        username\n      }));\n      return true;\n    }\n    console.warn('‚ö†Ô∏è WebSocket is not connected');\n    return false;\n  }, [username]);\n  return {\n    sendMessage,\n    isConnected,\n    reconnectAttempts: reconnectAttemptsRef.current\n  };\n};\n_s(useWebSocket, \"w3LYuUNHg+PUOImZaVaoY9lB/jw=\", false, function () {\n  return [useChatContext];\n});\nexport default useWebSocket;","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","useChatContext","useWebSocket","_s","wsRef","reconnectTimeoutRef","reconnectAttemptsRef","isConnectingRef","isConnected","setIsConnected","MAX_RECONNECT_ATTEMPTS","RECONNECT_DELAY","username","isLoggedIn","addMessage","setMessageHistory","setOnlineUsers","WS_URL","process","env","REACT_APP_WS_URL","handleMessage","event","data","JSON","parse","type","messages","message","count","error","console","current","connect","close","log","websocket","WebSocket","onopen","send","stringify","onmessage","onerror","onclose","code","reason","setTimeout","clearTimeout","sendMessage","text","readyState","OPEN","warn","reconnectAttempts"],"sources":["C:/Users/skk46/OneDrive/AppData/Desktop/chat-app-full/chat-app/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\r\nimport { useChatContext } from '../context/ChatContext';\r\n\r\nconst useWebSocket = () => {\r\n  const wsRef = useRef(null);\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const reconnectAttemptsRef = useRef(0);\r\n  const isConnectingRef = useRef(false);\r\n\r\n  const [isConnected, setIsConnected] = useState(false);\r\n\r\n  const MAX_RECONNECT_ATTEMPTS = 5;\r\n  const RECONNECT_DELAY = 3000;\r\n\r\n  const {\r\n    username,\r\n    isLoggedIn,\r\n    addMessage,\r\n    setMessageHistory,\r\n    setOnlineUsers,\r\n  } = useChatContext();\r\n\r\n  // ‚úÖ Get WebSocket URL with proper fallback\r\n  const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000';\r\n\r\n  // ‚úÖ Memoize the message handler to prevent recreating it\r\n  const handleMessage = useCallback((event) => {\r\n    try {\r\n      const data = JSON.parse(event.data);\r\n\r\n      if (data.type === 'history') {\r\n        setMessageHistory(data.messages);\r\n      } else if (data.type === 'message') {\r\n        addMessage(data.message);\r\n      } else if (data.type === 'users') {\r\n        setOnlineUsers(data.count);\r\n      }\r\n    } catch (error) {\r\n      console.error('‚ö†Ô∏è Error parsing message:', error);\r\n    }\r\n  }, [addMessage, setMessageHistory, setOnlineUsers]);\r\n\r\n  useEffect(() => {\r\n    if (!isLoggedIn || !username) {\r\n      return;\r\n    }\r\n\r\n    // Prevent multiple simultaneous connection attempts\r\n    if (isConnectingRef.current) {\r\n      return;\r\n    }\r\n\r\n    // Reset reconnect attempts when starting fresh\r\n    reconnectAttemptsRef.current = 0;\r\n\r\n    const connect = () => {\r\n      // Stop if max attempts reached\r\n      if (reconnectAttemptsRef.current >= MAX_RECONNECT_ATTEMPTS) {\r\n        console.error('üö´ Max reconnection attempts reached');\r\n        isConnectingRef.current = false;\r\n        return;\r\n      }\r\n\r\n      // Prevent multiple connections\r\n      if (isConnectingRef.current) {\r\n        return;\r\n      }\r\n\r\n      isConnectingRef.current = true;\r\n\r\n      // Close any existing connection\r\n      if (wsRef.current) {\r\n        wsRef.current.close();\r\n      }\r\n\r\n      console.log(`üîå Connecting to ${WS_URL}...`);\r\n      const websocket = new WebSocket(WS_URL);\r\n\r\n      websocket.onopen = () => {\r\n        console.log('‚úÖ Connected to server');\r\n        setIsConnected(true);\r\n        reconnectAttemptsRef.current = 0;\r\n        isConnectingRef.current = false;\r\n        websocket.send(JSON.stringify({ type: 'join', username }));\r\n      };\r\n\r\n      websocket.onmessage = handleMessage;\r\n\r\n      websocket.onerror = (error) => {\r\n        console.error('‚ö†Ô∏è WebSocket error:', error);\r\n        isConnectingRef.current = false;\r\n      };\r\n\r\n      websocket.onclose = (event) => {\r\n        console.log('‚ùå Disconnected from server', event.code, event.reason);\r\n        setIsConnected(false);\r\n        isConnectingRef.current = false;\r\n\r\n        // Only attempt reconnection if not a clean close and haven't exceeded max attempts\r\n        if (event.code !== 1000 && reconnectAttemptsRef.current < MAX_RECONNECT_ATTEMPTS) {\r\n          reconnectAttemptsRef.current += 1;\r\n          console.log(\r\n            `üîÑ Reconnection attempt ${reconnectAttemptsRef.current}/${MAX_RECONNECT_ATTEMPTS} in ${RECONNECT_DELAY}ms`\r\n          );\r\n          \r\n          reconnectTimeoutRef.current = setTimeout(() => {\r\n            connect();\r\n          }, RECONNECT_DELAY);\r\n        }\r\n      };\r\n\r\n      wsRef.current = websocket;\r\n    };\r\n\r\n    // Initial connection\r\n    connect();\r\n\r\n    // Cleanup function\r\n    return () => {\r\n      console.log('üßπ Cleaning up WebSocket connection');\r\n      \r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n        reconnectTimeoutRef.current = null;\r\n      }\r\n      \r\n      if (wsRef.current) {\r\n        // Set to max attempts to prevent reconnection during cleanup\r\n        reconnectAttemptsRef.current = MAX_RECONNECT_ATTEMPTS;\r\n        wsRef.current.onclose = null; // Remove onclose handler to prevent reconnection\r\n        wsRef.current.close(1000, 'Component unmounting');\r\n        wsRef.current = null;\r\n      }\r\n      \r\n      isConnectingRef.current = false;\r\n    };\r\n  }, [isLoggedIn, username, WS_URL, handleMessage]);\r\n\r\n  // ‚úÖ Send message helper - memoized to prevent recreating\r\n  const sendMessage = useCallback((text) => {\r\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\r\n      wsRef.current.send(\r\n        JSON.stringify({\r\n          type: 'message',\r\n          text,\r\n          username,\r\n        })\r\n      );\r\n      return true;\r\n    }\r\n    console.warn('‚ö†Ô∏è WebSocket is not connected');\r\n    return false;\r\n  }, [username]);\r\n\r\n  return { \r\n    sendMessage, \r\n    isConnected, \r\n    reconnectAttempts: reconnectAttemptsRef.current \r\n  };\r\n};\r\n\r\nexport default useWebSocket;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}